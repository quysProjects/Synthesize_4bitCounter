
// Generated by Cadence Genus(TM) Synthesis Solution GENUS15.20 - 15.20-p004_1
// Generated on: May 26 2024 11:47:51

// Verification Directory fv/synth_wrapper 

module fulladder(X, Y, Ci, S, Co);
  input X, Y, Ci;
  output S, Co;
  wire X, Y, Ci;
  wire S, Co;
  wire w1, w2, w3;
  xor G1 (w1, X, Y);
  xor G2 (S, w1, Ci);
  and G3 (w2, w1, Ci);
  and G4 (w3, X, Y);
  or G5 (Co, w2, w3);
endmodule

module ripple_adder(X, Y, S, Co, Cin);
  input [3:0] X, Y;
  input Cin;
  output [3:0] S;
  output Co;
  wire [3:0] X, Y;
  wire Cin;
  wire [3:0] S;
  wire Co;
  wire n_14, w1, w2, w3;
  assign Co = 1'b0;
  fulladder u1(X[0], Y[0], Cin, S[0], w1);
  fulladder u2(X[1], Y[1], w1, S[1], w2);
  fulladder u3(X[2], Y[2], w2, S[2], w3);
  fulladder u4(X[3], Y[3], w3, S[3], n_14);
endmodule

module mux2by1(D0, D1, S, Y);
  input D0, D1, S;
  output Y;
  wire D0, D1, S;
  wire Y;
  wire w1, w2, w3;
  not g1 (w1, S);
  and g2 (w2, D0, w1);
  and g3 (w3, D1, S);
  or g4 (Y, w2, w3);
endmodule

module mux2by1_4bit(in0, in1, sel, out);
  input [3:0] in0, in1;
  input sel;
  output [3:0] out;
  wire [3:0] in0, in1;
  wire sel;
  wire [3:0] out;
  mux2by1 mux0(in0[0], in1[0], sel, out[0]);
  mux2by1 mux1(in0[1], in1[1], sel, out[1]);
  mux2by1 mux2(in0[2], in1[2], sel, out[2]);
  mux2by1 mux3(in0[3], in1[3], sel, out[3]);
endmodule

module counter(clk_i, rst_ni, sel_i, data_o);
  input clk_i, rst_ni, sel_i;
  output [3:0] data_o;
  wire clk_i, rst_ni, sel_i;
  wire [3:0] data_o;
  wire [3:0] counter_down;
  wire [3:0] counter_up;
  wire [3:0] counter_d;
  wire UNCONNECTED, UNCONNECTED0, n_44, n_46, n_48, n_50;
  ripple_adder count_down(.X (data_o), .Y (4'b1111), .S (counter_down),
       .Co (UNCONNECTED), .Cin (1'b0));
  ripple_adder count_up(.X (data_o), .Y (4'b0000), .S (counter_up), .Co
       (UNCONNECTED0), .Cin (1'b1));
  mux2by1_4bit mux(counter_down, counter_up, sel_i, counter_d);
  CDN_flop \counter_q_reg[0] (.clk (clk_i), .d (n_44), .sena (1'b1),
       .aclr (1'b0), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (data_o[0]));
  CDN_flop \counter_q_reg[1] (.clk (clk_i), .d (n_46), .sena (1'b1),
       .aclr (1'b0), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (data_o[1]));
  CDN_flop \counter_q_reg[2] (.clk (clk_i), .d (n_48), .sena (1'b1),
       .aclr (1'b0), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (data_o[2]));
  CDN_flop \counter_q_reg[3] (.clk (clk_i), .d (n_50), .sena (1'b1),
       .aclr (1'b0), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (data_o[3]));
  and g12 (n_44, rst_ni, counter_d[0]);
  and g13 (n_46, rst_ni, counter_d[1]);
  and g14 (n_48, rst_ni, counter_d[2]);
  and g15 (n_50, rst_ni, counter_d[3]);
endmodule

module synth_wrapper(sel_i, rst_n, clk, data_o);
  input sel_i, rst_n, clk;
  output [3:0] data_o;
  wire sel_i, rst_n, clk;
  wire [3:0] data_o;
  wire \data_o_reg[0]_14 , \data_o_reg[1]_15 , \data_o_reg[2]_16 ,
       \data_o_reg[3]_17 , n_6, sel_i_reg;
  counter u1(.clk_i (clk), .rst_ni (rst_n), .sel_i (sel_i_reg), .data_o
       ({\data_o_reg[3]_17 , \data_o_reg[2]_16 , \data_o_reg[1]_15 ,
       \data_o_reg[0]_14 }));
  CDN_flop \data_o_reg[0] (.clk (clk), .d (\data_o_reg[0]_14 ), .sena
       (1'b1), .aclr (n_6), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (data_o[0]));
  CDN_flop \data_o_reg[1] (.clk (clk), .d (\data_o_reg[1]_15 ), .sena
       (1'b1), .aclr (n_6), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (data_o[1]));
  CDN_flop \data_o_reg[2] (.clk (clk), .d (\data_o_reg[2]_16 ), .sena
       (1'b1), .aclr (n_6), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (data_o[2]));
  CDN_flop \data_o_reg[3] (.clk (clk), .d (\data_o_reg[3]_17 ), .sena
       (1'b1), .aclr (n_6), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q
       (data_o[3]));
  not g1 (n_6, rst_n);
  CDN_flop sel_i_reg_reg(.clk (clk), .d (sel_i), .sena (1'b1), .aclr
       (n_6), .apre (1'b0), .srl (1'b0), .srd (1'b0), .q (sel_i_reg));
endmodule

`ifdef RC_CDN_GENERIC_GATE
`else
module CDN_flop(clk, d, sena, aclr, apre, srl, srd, q);
  input clk, d, sena, aclr, apre, srl, srd;
  output q;
  wire clk, d, sena, aclr, apre, srl, srd;
  wire q;
  reg  qi;
  assign #1 q = qi;
  always 
    @(posedge clk or posedge apre or posedge aclr) 
      if (aclr) 
        qi <= 0;
      else if (apre) 
          qi <= 1;
        else if (srl) 
            qi <= srd;
          else begin
            if (sena) 
              qi <= d;
          end
  initial 
    qi <= 1'b0;
endmodule
`endif
